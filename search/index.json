[{"content":" 前言\u0026amp;介绍 为什么要在本地部署deepseek模型？\n由于deepseek之前受到过攻击，官网地址经常会出现无响应的情况，久久不能得到回复，这种结果显然是无法接受的。本地部署可以更好的进行模型的调试和测试，可以更快的得到结果。\n本地部署可以更好的满足一些特殊的需求，比如：对于一些数据集，没有足够的训练集，可以自己选择是否喂养训练集。\n什么是deepseek模型？\ndeepseek是一个基于深度学习的语言模型，可以生成文本。它可以生成的文本可以用来训练机器翻译、文本摘要、文本生成等任务。 本地部署 安装OLLAMA OLLAMA下载 我们需要从OLLAMA上下载并且管理我们的deepseek模型。\nOLLAMA可以直接去官网下载，官网地址，也可以去github上下载，github地址，github就是点击release这里下载。\nOLLAMA常用指令和配置 1 2 ollama # 输出ollama帮助信息，如果有输出则说明安装成功 ollama list # 列出所有模型，后续用到的模型名称就从这里复制即可 后续还需要对ollama进行配置，增加两个环境变量 1 2 OLLAMA_HOST\t0.0.0.0:11434 # 记住这个11434端口 OLLAMA_MODELS\t/path/to/ollama/models 这里的/path/to/ollama/models就是你下载的模型的存放路径，比如：E:\\ollama\\models。 下载deepseek模型 直接在OLLAMA上搜索deepseek就可以找到我们要的模型。 V3和R1，我会直接选择R1，因为我需要他来帮助我进行工作上的需求。 复制下来这个指令，然后在CMD中运行。如果没有下载对应的模型，则会帮你自动下载，如果已经下载好了则是直接运行。然后就可以进行正常的对话了。 回复/bye就可以结束对话 让deepseek可视化，定制功能 下载RagFlow，安装Docker 我们需要用到RagFlow这个LLM开源框架，github地址。\n不是一定要用git指令去下载，我们可以直接下载zip压缩包，解压到自己想要的目录即可。 在使用RagFlow之前，我们还需要安装Docker，官网地址。\n下载好Docker之后，我们还需要进行一点简单的配置(Docker 无需登录，跳过即可)。 在下面新增一段内容： 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;builder\u0026#34;: { \u0026#34;gc\u0026#34;: { \u0026#34;defaultKeepStorage\u0026#34;: \u0026#34;20GB\u0026#34;, \u0026#34;enabled\u0026#34;: true } }, \u0026#34;experimental\u0026#34;: false, \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub.rat.dev\u0026#34; ] } 下面的registry-mirrors是新增的镜像源地址，防止访问不到国外源。 启动RagFlow 把RagFlow解压到自己想要的目录，然后进入到RagFlow目录\n启动之前先修改一下设置，完整版的功能更加强大一些。 之后就可以在RagFlow目录下打开CMD，输入以下指令启动RagFlow。\n1 docker compose -f docker/docker-compose.yml up -d 首次启动应该会有一个拉取过程，需要几分钟时间。\n然后我们就可以在浏览器中打开http://localhost:80/，就可以看到RagFlow的界面了。\n手动下载zip可以免去git下载的过程，，手动进入RagFlow目录打开CMD运行指令即可。 RagFlow的使用 首次进去需要注册账号，账号都是存在本地的，无需担心泄密问题，首个注册账号的人将会自动成为管理员。\n添加模型 点击自己的头像，然后点击左侧模型提供商。找到OLLAMA并且点击下面的添加模型，由于我已经添加过了，OLLAMA会在上面，如果没有添加过的话，OLLAMA会在下面(请把下面的ZHIPU-AI当做OLLAMA即可)。 这里填的时候要注意一下，模型名称必须和OLLAMA LIST中显示的一致。 下面的这个基础URL，把localhost换成自己的IPV4地址即可，不换应该也可以添加成功，后面的11434端口是我们之前配置的环境变量，如果出现无法添加的情况，请检查一下这个环境变量是否正确。 模型添加完毕之后也要改一下系统模型设置(右上角那个蓝色按钮) 添加知识库 构建知识库 添加知识库的时候，要注意一下语言和权限，还有注意解析方法，可以根据文件的类型选择不同的解析方法。 之后是添加文件内容，可以添加多个文件，也可以添加文件夹，RagFlow会自动递归查找。 如果是未解析状态，还需要自己去解析 对话 对话必须用到知识库，所以可以等到知识库解析完毕之后再去对话。这几个设置我也不是完全了解，就不多介绍了。 对话效果 其他 安装完OLLAMA，把模型下载到本地之后就可以进行对话了，如果这个文档有什么不清楚的地方，就可以找AI问，AI可以进行辅助解答。\n","date":"2025-02-06T14:47:32+08:00","image":"https://wustzhh.github.io/Hugo-stack/p/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2deepseek%E6%A8%A1%E5%9E%8B/emilia_hu_7b612a6f59a2c1cb.png","permalink":"https://wustzhh.github.io/Hugo-stack/p/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2deepseek%E6%A8%A1%E5%9E%8B/","title":"本地部署deepseek模型"},{"content":" 准备 我们将使用HyperMesh软件2022版本进行点线几何编辑。主要操作的就是下面这一排，后面框内是具体的点线操作。前面的是选择一个表面进行编辑或者一个plane作为草图。 选中表面或者草图成功之后会出现这样一大片的画布。另外两个Project和Intersected也是类似的操作。 点操作 创建点 点击菜单栏的这个点，就可以再画布上面点击创建点了，再次点击创建过的点，按一下键盘上的delete键就可以删除点。\n视频中还有一些其他操作的菜单，应该是因为版本的差异少了一些选项，我这里没有找到在哪。\n线操作 1. 创建点，线段，连续折线 选中这个就可以再画布上点击两个点生成一条直线段 选中这个，则是生成连续的线段。再次点击可以中止本次操作。 2. 创建矩形 这个创建矩形。四种图标分别对应了四种不同的创建方式，前两种只能创建这种横平竖直的矩形，后两种可以创建斜着的矩形 3. 创建平行四边形和正多边形(3-8) 这里两个一个是创建平行四边形，一个是默认创建正六边形，是的，虽然图标是正五边形，但是这个确实是正六边形。 默认的边数可以自己调节。 4. 创建圆 这三种创建圆的方式分辨是通过直径确定圆，圆心加半径确定圆，以及在圆上三点来确定圆。 5. 创建椭圆 这个是创建椭圆，左上是确定圆心，然后确定长短轴。右下是先创建好一个椭圆之后再选择其中的一段弧线。 6. 创建圆弧 这里的第一个是延伸，或者说在某个线的断点之后延伸一段圆弧。 第二个就是创建一段圆弧，操作类似于用中垂线创建圆的那一步。 第三个也是创建圆弧，操作类似于圆心-半径创建圆的那一步。 7. 创建贝塞尔曲线 这个是创建贝塞尔曲线，两种创建方式的区别就是在于第二个在创建的时候会把辅助线给标记出来。而第一个则是会直接穿过指定的位置。 这个文章详细讲解了贝塞尔曲线，如果不了解可以看看。贝塞尔曲线。 8. 其他操作 这个是测量两条线之间的距离，并且可以改变他们的距离，但是我试了几次貌似都是左边的固定，右边的在移动。 9. 删除线和分割线 这两个，上面的是删除线，下面的是分割线。 10. 曲线延伸 这个是曲线延伸，但是只能延伸圆，椭圆，直线这种简单类型的。对于贝塞尔曲线是无法选中的。 11. 去尖角顶点 这个是去直角，把尖角变成弧线链接起来，但是貌似不是很平滑。 但是在大面积的图形上看着还是蛮不错的。 12. 镜像图形和复制图形 镜像一份图形，要注意选中的图形得完整，不能是一部分。 创建一个线(可以是复合曲线)的复制，并且将它放大或者缩小。还是不可以选中贝塞尔曲线。 ","date":"2025-01-13T14:34:24+08:00","image":"https://wustzhh.github.io/Hugo-stack/p/25.01.13_hypermesh%E7%82%B9%E7%BA%BF%E7%BC%96%E8%BE%91/emilia_hu_f9f6e4622a744a52.jpg","permalink":"https://wustzhh.github.io/Hugo-stack/p/25.01.13_hypermesh%E7%82%B9%E7%BA%BF%E7%BC%96%E8%BE%91/","title":"25.01.13_HyperMesh点线编辑"},{"content":" 序言 滑动窗口一直以来都是我不曾注意到的，直到上班之后和同事聊天的时候才知道有这么个算法。恰巧最近做题的时候经常碰到，就专门整理一下。 本文的题目全都来自LeetCode，题单则是来自灵茶山艾府的题集 最后一题没做，因为我没看懂题目。\n题解和代码 795. 区间子数组个数 题目分析 题目要求最大元素处于[left, right]之间，这就意味着，如果nums[i] \u0026gt; right，那么nums[i]所在的子数组都是不符合条件的，就都得去掉，由此可以看出，大于right的元素都是用来分隔的。 第二，如果nums[i] \u0026lt; left，那么nums[i]自身是不可以作为一个独立的子数组的。\n分析示例2：由于9大于right(8)，所以9把数组分成了两个部分，且互不干扰。分别是[2]和[2, 5, 6] 对于[2]，有且仅有一个元素，对于[2, 5, 6]，则是[2], [2, 5], [2, 5, 6], [5], [5, 6], [6]共6个子数组。 可以思考一下，如果[2, 5, 6]再加一个7，会多出多少个解呢，答案是以6结尾的数组加上单独的7，一共是4个。 以6结尾的数组，肯定是6之前的元素数量，也就是数组长度了。同理，对于处于[left, right]之间的元素，我们的规律已经找到了。\n如果新增的不是7，而是1呢，很显然，1不能独立作为一个子数组，所以新增的是三个解 如果再次新增一个1，变为[2, 5, 6, 1, 1]，那么第二个1可以新增多少个解呢，答案也是3个，因为比left小的元素，不能作为独立的子数组，所以必须依赖最后一次出现的处于[left, right]中的元素。\n代码实现 展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; class Solution { public: int numSubarrayBoundedMax(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int n = nums.size(); int ans = 0, l = 0, r = -1; for (int i = 0; i \u0026lt; n; i++) { if (nums[i] \u0026gt; right)\tl = i + 1; if (nums[i] \u0026gt;= left)\tr = i; ans += r - l + 1; } return ans; } }; 最后贴一下战绩： 1658. 将 x 减到 0 的最小操作数 题目分析 题目的意思是可以从数组首尾任选一个数，使得选中的数恰好等于x。 按照题目的意思来肯定不好做，但是我们可以反过来，从数组当中去掉一个子数组，使得子数组的和恰好等于，sum(nums) - x。 所以这个就恰好无缝衔接到了滑动窗口。\n代码实现 展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; class Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int n = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); if (sum \u0026lt; x)\treturn -1; if (sum == x)\treturn n; int ans = -1; int target = sum - x; int left = 0, right = 0; int index = 0; int cur_sum = 0; while (true) { while (cur_sum \u0026lt; target \u0026amp;\u0026amp; index \u0026lt; n) { cur_sum += nums[index]; index++; } do { if (cur_sum == target)\tans = max(ans, index - left); cur_sum -= nums[left]; left++; } while (cur_sum \u0026gt;= target \u0026amp;\u0026amp; left \u0026lt; index); if (index \u0026gt;= n) break; } return ans == -1 ? -1 : n - ans; } }; 贴战绩: 1234. 替换子串得到平衡字符串 题目分析 这个题目还是比较简单的，QWER本来的比例是相等的，如果有字母多了，那就必然有字母少了，我们只需要找到一段子串，至少包含多出来的那些字母就行了。\n代码实现 展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; class Solution { public: int balancedString(string s) { int n = s.length(); int type[128] = {0}; type[\u0026#39;Q\u0026#39;] = 0; type[\u0026#39;W\u0026#39;] = 1; type[\u0026#39;E\u0026#39;] = 2; type[\u0026#39;R\u0026#39;] = 3; int cnt[4] = {0}; int cnt_now[4] = {0}; int c = 0; for (int i = 0; i \u0026lt; n; i++) { c = type[s[i]]; cnt[c]++; } vector\u0026lt;int\u0026gt; overChars(4, 0); int len_over = 0; for (int i = 0; i \u0026lt; 4; i++) { c = i; if (cnt[c] \u0026gt; (n / 4)) { overChars[c] = cnt[c] - (n / 4); len_over++; } } if (len_over == 0)\treturn 0; int left = 0, right = 0, res = n; int over_cnt = 0; while (right \u0026lt; n) { while (right \u0026lt; n \u0026amp;\u0026amp; over_cnt \u0026lt; len_over) { c = type[s[right]]; cnt_now[c]++; if (cnt_now[c] == overChars[c]) { over_cnt++; } right++; } while (left \u0026lt; n \u0026amp;\u0026amp; over_cnt == len_over) { res = min(res, right - left); c = type[s[left]]; cnt_now[c]--; if (cnt_now[c] == overChars[c] - 1) { over_cnt--; } left++; } } return res; } }; 贴战绩: 1574. 删除最短的子数组使剩余数组有序 题目分析 题目要求我们找到一个子数组，删除它之后，剩余数组仍然有序。对于这个题目来说，如果有多段有序子数组的话，其实中间的都是要删掉的，我们的目标仅仅是把一头一尾拼接起来。 因为中间的段落一定会是在第一段最后的数要小的那个数之后的，所以不满足。同理和最后一段最开始的数相比也是，所以中间的都得删掉。我们就只需要比较一头一尾两段即可。\n代码实现 展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; class Solution { public: int findLengthOfShortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); int left = 0, right = n - 1, ans = n - 1; for (int i = n - 2; i \u0026gt;= 0; i--) { if (arr[i] \u0026lt;= arr[i + 1]) { right = i; } else { break; } } if (right == 0)\treturn 0; ans = right; for (int i = 0; i \u0026lt; n; i++) { left = i; while (right \u0026lt; n \u0026amp;\u0026amp; arr[left] \u0026gt; arr[right]) { right++; } ans = min(ans, right - left - 1); if (i == n - 1 || arr[i] \u0026gt; arr[i + 1]) { break; } } return ans; } }; 贴战绩: 2106. 摘水果 题目分析 题目要求我们能采摘的果子下标是有范围的，就是[startPos - k, startPos + k] 如果我们要采摘从[l, r]的果子，我们会用到多少步数，可以分情况讨论: 如果l和r在同一侧，就是max(abs(r - startPos), abs(startPos - l)) 如果l和r在不同侧，就是r - l + min(abs(r - startPos), abs(startPos - l))\n代码实现 展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; class Solution { public: int maxTotalFruits(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; fruits, int startPos, int k) { int n = fruits.size(); int left = -1; int right = -1; for (int i = 0; i \u0026lt; n; i++) { if (fruits[i][0] \u0026gt;= startPos - k \u0026amp;\u0026amp; left == -1)\tleft = i; if (fruits[i][0] \u0026lt;= startPos + k)\tright = i; } int l = left; int r = left; if (left == -1 || right == -1)\treturn 0; int ans = 0; int nowStep = 0; int nowFruits = 0; int li = 0; int ri = 0; while (r \u0026lt;= right) { while (r \u0026lt;= right \u0026amp;\u0026amp; nowStep \u0026lt;= k) { li = fruits[l][0]; ri = fruits[r][0]; if (ri \u0026lt;= startPos \u0026amp;\u0026amp; li \u0026lt;= startPos || ri \u0026gt;= startPos \u0026amp;\u0026amp; li \u0026gt;= startPos) { nowStep = max(abs(ri - startPos), abs(startPos - li)); } else { nowStep = ri - li + min(abs(ri - startPos), abs(startPos - li)); } nowFruits += fruits[r][1]; r++; if (nowStep \u0026gt; k)\tbreak; ans = max(ans, nowFruits); } while (l \u0026lt;= right \u0026amp;\u0026amp; nowStep \u0026gt; k) { li = fruits[l + 1][0]; ri = fruits[r - 1][0]; if (ri \u0026lt;= startPos \u0026amp;\u0026amp; li \u0026lt;= startPos || ri \u0026gt;= startPos \u0026amp;\u0026amp; li \u0026gt;= startPos) { nowStep = max(abs(ri - startPos), abs(startPos - li)); } else { nowStep = ri - li + min(abs(ri - startPos), abs(startPos - li)); } nowFruits -= fruits[l][1]; l++; if (nowStep \u0026lt;= k) { ans = max(ans, nowFruits); break; } } } return ans; } }; 贴战绩: ","date":"2024-11-02T13:17:43+08:00","image":"https://wustzhh.github.io/Hugo-stack/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/emilia_hu_2093212f45857cd4.png","permalink":"https://wustzhh.github.io/Hugo-stack/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","title":"滑动窗口"},{"content":" 序言 这是这个博客的第一篇文章，所以自然要记录怎么建立这个博客，以防后面换电脑导致博客丢失。\n如何使用Hugo搭建静态博客 下载Hugo 首先去搜索Hugo官网，也就是这个地址 点击这个按钮 进入github页面后点击这个tags 选择最新版本 拉到最下面之后选择下面这个 解压完成之后就可以看到这几个文件了\n使用Hugo配置主题 打开命令行，进入Hugo的安装目录，比如我的目录是E:\\Hugo_blog\\hugo_extended_0.136.5_windows-amd64 最简单的方法就是在地址栏输入cmd，然后回车，进入命令行，并且进入当前目录 输入hugo new site zhhHugoBlog创建新站点，然后进入目录cd zhhHugoBlog 由于进入了新目录之后没有hugo.exe文件，所以我们需要把刚才下载的Hugo解压后的目录下的hugo.exe文件复制到zhhHugoBlog目录\n进来之后是什么都没有的，所以我们需要一个新的主题来开始写博客，这里我推荐的主题是stack 首先进入Hugo官网，点击这个theme按钮 如图所示的第三个就是 然后依次点击如下按钮 把下载来的zip文件解压到zhhHugoBlog\\themes目录下 并且把这个主题的文件夹改个名字，把后面的版本号给去掉，后面说配置的时候会说原因的\n还没完，我们需要把这两个文件复制下来，放到主目录下 然后把主目录下的hugo.toml给删了，这个文件和刚刚复制过来的hugo.yaml是一样的，我们只需要一个 进入这个目录，并且把这个文件夹给删了 这个目录下面就是我们的博客，每一篇博客都是一个独立的文件夹，他里面用到了油管的链接，需要翻墙才能正常加载，我们不需要，所以就直接删了，避免卡顿\n创建文章，并且开始写博客 打开刚刚的控制台，输入hugo new post/如何使用Hugo+github搭建博客/index.md创建新文章 回到控制台，输入hugo server -D启动本地服务器，实时预览 复制控制台给的网址，在浏览器打开即可看到刚刚的主题和文章 此后写博客大抵都是这个流程，博客的内容在index.md文件里面修改就行了 如果要支持多语言的话，index.md还需要加上语言标识符，比如index.zh-cn.md或者index.en.md，但是我没有打算做英文的博客，所以就只用index.md了，后面讲配置的时候会说怎么把多语言给去掉的\nHugo常用命令 1 2 3 4 hugo new site my-blog # 创建新站点 hugo new post/my-first-post.md # 创建新文章 hugo server -D # 启动本地服务器，实时预览 hugo -d public # 生成静态文件 配置Hugo主题 stack主题配置 进入主题目录，打开hugo.yaml文件，这个就是stack主题提供的默认配置文件，我们需要作亿点点修改 来介绍一下配置文件里面的参数 baseURL: 这个参数是网站的根目录，之后会修改成github上面的仓库地址作为我们的博客的根目录 languageCode: 这个参数是网站的默认语言，可以不用改，没什么影响 theme: 这个参数就是看你要使用哪一个主题，比如说我们这里使用的是stack主题，那么就要stack主题的文件夹的名字，所以我们刚刚把主题文件夹后面的版本号删掉之后就是这个配置文件的默认值了 title: AI说[这个参数是网站的标题，可以改成你喜欢的标题]，但是我没有找到这个参数有什么用，建议删掉 paginate: 每一页有多少篇文章，有些版本可能删掉了，但是没有关系，我们可以自己加上来 copyright: 版权信息，可以删掉，也可以加上自己的信息，对应的是这里\n语言设置: title和subtitle: 这两个参数是网站的标题和副标题，对应的就是这两个地方 当我们把语言删掉只剩一个中文的时候，网页上对应的语言设置就没了，了却了一些烦恼，记得把hasCJKLanguage改成true，会让字数统计变得准确一点 这几个都是没有什么用的东西，直接看图片的注释就好了\n接下来的属性都是在params下面的 footer: 网站的页脚，表示博客是从哪一年开始的，如果距今超过一年，就会显示xxxx-xxxx dateFormat中的published：用来设置文章发布日期的格式，lastUpdated：应该是文章最后一次更新时间的格式 sidebar：设置头像和头像下面的表情的，要提一下的是头像的路径在这里，主题根目录下也有，但是站点根目录的优先级比较高，所以在站点根目录下放置一份就好 article：math属性是用来开启数学公式的，需要设置写数学公式的时候开启。toc：表示是否显示目录，true表示显示，false表示不显示。readingTime：显示文章阅读时间，没什么用，开不开都行。license：文章末尾的版权信息，可以删掉，也可以加上自己的信息。 comments: 评论功能，这个图里面的整个comments下面都是可选的评论框架。使用起来很简单，参考这片博客就行了 如何给Hugo博客添加评论功能 特别注意一下utterances，这个是完全免费的。 这里的就是widgets界面右边的功能栏，homepage对应主页的几个功能，page的这个是表头 这几个都没什么用，也不知道干嘛的，不管他就好，colorScheme可以设置主题颜色，但是亮暗两种就够用了，先不管。 这里就是对应的这个，可以转到自己其他的页面去看看，比如B站\n最后还有首页的几个文件在这里面改。\n部署到github 常规部署 首先需要自己去下载git，然后用指令初始化一下账号信息 新建一个仓库，名字可以随意 之后立刻把仓库的网址复制到配置文件的baseURL参数中。特别注意，如果你的仓库不是github名.github.io，那么你需要在URL后面加上刚刚的仓库名作为子路径。\n删除掉这里的public 然后在控制台输入hugo -D重新生成静态文件 之后进入public按照github的提示上传文件，只有第二步需要修改，改成git add . 如果部署失败，有可能是git没有初始化用户名导致的\n上传成功之后，来到github仓库的setting这里选择main分支点击save 过一会之后刷新，就可以看到你得博客了。 如果看到这种失败，这种是因为网络问题导致的，多试几次。\n自动部署 上传的私有仓库 在根目录下面创建一个.gitignore文件，并且写下以下信息，把几个不需要的文件排除掉 之后按照常规部署的操作来一遍，但是这一次是上传根目录的文件，不再是public了，记得把这一次的仓库设置为私有。\n生成token准备自动部署 首先到github上生成一个token，这个token可以用来自动部署，而不是用自己的账号密码。 按以下步骤点击。 把repo和workflow勾选上，然后点击generate token，复制生成的token 把token作为参数添加到这个仓库的Secrets里面(防止出现明文泄露)，名字随便取，比如Hugo_TOKEN\n私有仓库自动部署 在根目录下连续新建三层文件，最后的文件名随便取，必须是yaml格式，之后把如下内容复制进去，记得替换一下关键信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 对我来说就是只改这里\n自动部署测试 上述做完之后进入根目录，打开cmd，连续输入以下命令 git add . git commit -m \u0026quot;update\u0026quot; git push\n由于更换了电脑，可能是设置不太一样了，导致命令也会有差异，git push也可以换成git push origin main\n","date":"2024-10-31T17:56:17+08:00","image":"https://wustzhh.github.io/Hugo-stack/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/emilia_hu_8ee94312271db9e4.png","permalink":"https://wustzhh.github.io/Hugo-stack/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"如何使用Hugo+github搭建博客"}]